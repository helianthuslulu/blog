cp命令占用双倍内存问题
====


**使用cp命令拷贝1GB大小的文件，会占用2GB的内存**

在linux下 使用cp命令拷贝东西时，会发现使用内存大小会变小 。例如下面的例子

    free -m
                 total       used       free     shared    buffers     cached
    Mem:          1892        117       1775          0          0         14
    -/+ buffers/cache:        103       1789
    Swap:         4095         92       4003

>

    time cp tmp /mnt/raid-data/
    
    real    0m9.278s
    user    0m0.009s
    sys     0m1.468s

>

    free -m
                 total       used       free     shared    buffers     cached
    Mem:          1892       1663        229          0        512       1038
    -/+ buffers/cache:        112       1780
    Swap:         4095         92       4003

cp前后，used内存从117MB变成啦1663MB。。。 cp 前后Mem内存变小了。内存没有释放吗？
这是一个普遍错误的观点。。      available memory=free+buffers+cached 也就是说 可用
内存 是 free -m 的第二行。而不是第一行。。。

那么linux为什么要这样子做呢？

cp 命令将文件从一个地方读取出来，又写到另一部分去，所以只要还有闲着的内
存，Linux 内核就会将这两份数据放在内存中，使得内存中有效数据量增加两个所
复制文件的大小。

如果真是这样子的话，那么是不是缓存一份就好了，为什么要留两份呢？

不过内核不知道源文件和目标文件一样，所以两份都会保存
当你读源文件时，内核就把源文件给缓存了。当你写目标文件的时候，系统顺便把目标文件缓存下来了。
嗯，其实一份就够了。不过内核不知道源文件和目标文件一样，所以两份都会保存。

为什么这样设计呢？
当你读过或写过一次文件后，如果缓存起来，下次用的时候就不用从硬盘里读取了，速度会快很多。反正内存闲着也是闲着，没好处。

至于如果有程序需要大量内存，必须释放缓存的文件的话，其实开销很小的。内存释放的时候，只是说一声某段内存可以用了而已，并没有真的给那段内存清零啊，下次写上去的时候直接覆盖就行了。
就像以前的磁带录音机，一盘磁带的内容你如果不要了，你只是简单的把那盘带子标记为“空”，下次录东西就直接覆盖上去了，你不会专门录一整盘带子的无声进去的。

使用200MB cache与1GB cache，为什么速度没有差别？
不管你有多少缓存，读写的速度还是受限与磁盘IO。反正，你一共要读500MB数据，要写500MB数据，
花的时间就是这点了。区别在于，你要是再拷贝一份文件，就可以省去读的那500MB。
我的实验：一个1G左右大文件，移动硬盘（本机SSD太快了，不方便计时）cp source target1 
花费了1分10秒，再次执行cp source target2  花费了35秒。验证了刚才说的，
第二次复制的时候不必再读了。
cp文件毕竟是少数情况。多数情况如你打开一个程序；或者编辑一个文件，存盘后一会儿再打开；
或者你的机器做ftp服务器；或者bt上传做种，这种机制的好处就很明显了。

一般看free，都是要看第二行的，不算Cache。Cache的内存其实不能算被占用的——Windows里也有cache
，但是你用任务管理器，它都不告诉你Cache了多少，直接把free+cache显示给你当做空闲内存。



























    






